<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Fault-Driven Memory Tracking</title>

    <link rel="stylesheet" href="../dist/reset.css">
    <link rel="stylesheet" href="../dist/reveal.css">
    <link rel="stylesheet" href="../dist/custom.css">
    <link rel="stylesheet" href="../dist/theme/dusk.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="../plugin/highlight/dusk.css">
</head>
<body>
<div class="qr-container mobile-hide" style="position: relative">
    <img class="qr" alt="qr" src="../images/meetup-qr.svg">
</div>

<div class="reveal">
    <div class="slides">
        <section>
            <section>
                <h3>Fault-Driven Memory Tracking</h3>
                <p>Segfaults ain't all bad</p>
            </section>
            <section>
                <div class=intro>
                    <div class=contact-info>
                        <div class=contact-row>
                            Eduardo Leegwater Sim√µes
                        </div>
                        <div class=contact-row>
                            Software Engineer
                        </div>
                        <div class=contact-row>
                            <a class=contact-link href="https://www.linkedin.com/in/eduardo-leegwater-sim%C3%B5es" target="_blank">
                                <img src="../images/linkedin-logo.svg" alt="linkedin">
                            </a>
                            <a class=contact-link href="https://github.com/ureeves" target="_blank">
                                <img src="../images/github-logo.svg" alt="github">
                            </a>
                            <a class=contact-link href="mailto:soft@ureeves.com" target="_blank">
                                <img src="../images/email-round.svg" alt="email">
                            </a>
                        </div>
                    </div>

                    <div class=company-logos>
                        <img class=contact-logo-dusk src="../images/dusk-logo.svg" alt="dusk">
                        <img class=contact-logo-rust src="../images/rust-logo.png" alt="rust">
                    </div>
                </div>
            </section>
        </section>
        <section>
            <section>
                <h3>Virtual Machine</h3>
            </section>
            <section data-transition=none>
                <h3>Virtual Machine</h3>
                <img class="virtual-machine" src="../images/virtual-machine.svg" alt="vm">
            </section>
            <section data-transition=none>
                <h3>Virtual Machine</h3>
                <img class="virtual-machine" src="../images/virtual-machine-memory.svg" alt="vm-memory">
            </section>
            <section data-transition=none>
                <h3>Virtual Machine</h3>
                <img class="virtual-machine" src="../images/virtual-machine-memory-state.svg" alt="vm-memory-state">
            </section>
            <section data-transition="none slide-in">
                <img class="virtual-machine" src="../images/single-contract-memory.svg" alt="single-contract-memory">
            </section>
            <section data-transition=none>
                <img class="virtual-machine" src="../images/single-contract-memory-dirty.svg" alt="single-contract-memory-dirty">
            </section>
            <section data-transition=none>
                <img class="virtual-machine" src="../images/single-contract-memory-dirty-os.svg" alt="single-contract-memory-dirty-os">
            </section>
        </section>
        <section>
            <section>
                <h3>Memory Tracking</h3>
            </section>
            <section>
                <p class=syscall-title>mmap(), munmap()</p>
                <p class=syscall-description>map or unmap files or devices into memory</p>
                <pre><code lang=c data-trim data-noescape>
                    #include &ltsys/mman.h&gt

                    void *mmap(void addr[.length], size_t length, int prot,
                               int flags, int fd, off_t offset);

                    int munmap(void addr[.length], size_t length);
                </code></pre>
            </section>
            <section data-transition=slide-in>
                <div class=syscall-signals>
                    <p>Use of a mapped region can result in these signals:</p>

                    <p class=syscall-signal>SIGSEGV</p>
                    <p class=syscall-signal-description>Attempted to write to a region mapped as read-only.</p>

                    <p class=syscall-signal>SIGBUS</p>
                    <p class=syscall-signal-description>
                       Attempted access to a page of the buffer that lies
                       beyond the end of the mapped file.
                    </p>
                </div>
            </section>
            <section data-transition=none>
                <div class=syscall-signals>
                    <p>Use of a mapped region can result in these signals:</p>

                    <p class=syscall-signal-highlight>SIGSEGV</p>
                    <p class=syscall-signal-description>Attempted to write to a region mapped as read-only.</p>

                    <p class=syscall-signal>SIGBUS</p>
                    <p class=syscall-signal-description>
                       Attempted access to a page of the buffer that lies
                       beyond the end of the mapped file.
                    </p>
                </div>
            </section>
            <section>
                <p class=syscall-title>sigaction()</p>
                <p class=syscall-description>examine and change a signal action</p>
                <pre><code lang=c data-trim data-noescape>
                    #include &ltsignal.h&gt

                    int sigaction(
                        int signum,
                        const struct sigaction *_Nullable restrict act,
                        struct sigaction *_Nullable restrict oldact
                    );
                </code></pre>
            </section>
            <section>
                <p class=syscall-title>mprotect()</p>
                <p class=syscall-description>set protection on a region of memory</p>
                <pre><code lang=c data-trim data-noescape>
                    #include &ltsys/mman.h&gt

                    int mprotect(void addr[.len], size_t len, int prot);
                </code></pre>
            </section>
            <section>
                <h3>Memory Tracking</h3>
                <h4 style="margin-bottom: 1em">Strategy</h4>
                <ol>
                    <li class="fragment stategy-item">Map memory region as read-only</li>
                    <li class="fragment stategy-item">Catch write using SIGSEGV handler</li>
                    <li class="fragment stategy-item">Mark memory region as written</li>
                    <li class="fragment stategy-item">Allow writing to the memory region</li>
                </ol>
            </section>
        </section>
        <section>
            <section>
                <div class=lets-code>
                    <h3 class=lets-code-title>Let's Code</h3>
                    <a class=lets-code-link href="https://github.com/ureeves/presentations/tree/ureeves/code/meetup" target="_blank">
                        <img src="../images/github-logo.svg" alt="github">
                    </a>
                </div>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    struct Mmap&ltT&gt {
                        ptr: *mut T,
                        len: usize,
                        n_bytes: usize,
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    impl&ltT&gt Mmap&ltT&gt {
                        fn new(len: usize, read_only: bool) -> io::Result&ltSelf&gt {
                            unsafe {
                                let mut n_bytes = len * mem::size_of::&ltT&gt();
                                let page_size = system_page_size();

                                // pad n_bytes to be a multiple of page size
                                let n_bytes_rem = n_bytes % page_size;
                                if n_bytes_rem != 0 {
                                    n_bytes += page_size - n_bytes_rem;
                                }

                                let prot = if read_only {
                                    PROT_READ
                                } else {
                                    PROT_READ | PROT_WRITE
                                };

                                let ptr = libc::mmap(
                                    ptr::null_mut(),
                                    n_bytes,
                                    prot,
                                    MAP_PRIVATE | MAP_ANONYMOUS,
                                    -1,
                                    0,
                                );
                                if ptr == MAP_FAILED {
                                    return Err(io::Error::last_os_error());
                                }

                                Ok(Mmap {
                                    ptr: ptr as _,
                                    len,
                                    n_bytes,
                                })
                            }
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    impl&ltT&gt Drop for Mmap&ltT&gt {
                        fn drop(&mut self) {
                            unsafe {
                                libc::munmap(self.ptr as _, self.n_bytes);
                            }
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    impl&ltT&gt AsRef<[T]> for Mmap&ltT&gt {
                        fn as_ref(&self) -> &[T] {
                            unsafe { slice::from_raw_parts(self.ptr, self.len) }
                        }
                    }

                    impl&ltT&gt AsMut<[T]> for Mmap&ltT&gt {
                        fn as_mut(&mut self) -> &mut [T] {
                            unsafe { slice::from_raw_parts_mut(self.ptr, self.len) }
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    struct MemoryInner {
                        bytes: Mmap&ltu8&gt,
                        dirty_page_bits: Mmap&ltAtomicBool&gt,
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    impl MemoryInner {
                        fn new(len: usize) -> io::Result&ltSelf&gt {
                            let bytes = Mmap::new(len, true)?;

                            let n_pages = bytes.n_bytes / system_page_size();
                            let dirty_page_bits = Mmap::new(n_pages, false)?;

                            Ok(MemoryInner {
                                bytes,
                                dirty_page_bits,
                            })
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    impl MemoryInner {
                        unsafe fn process_segv(&mut self, si_addr: usize) -> io::Result<()> {
                            let start_addr = self.bytes.ptr as usize;

                            let page_size = system_page_size();
                            let page_index = (si_addr - start_addr) / page_size;
                            let page_addr = start_addr + page_index * page_size;

                            let was_dirty = self.dirty_page_bits.as_mut()[page_index]
                                .fetch_or(true, Ordering::SeqCst);

                            if !was_dirty
                                && libc::mprotect(page_addr as _, page_size, PROT_READ | PROT_WRITE)
                                    != 0
                            {
                                return Err(io::Error::last_os_error());
                            }

                            Ok(())
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    type MemoryMap = RangeMap&ltusize, usize&gt;;

                    fn global_memory_map() -> &'static RwLock&ltMemoryMap&gt {
                        static MEMORY_MAP: OnceLock&ltRwLock&ltMemoryMap&gt&gt = OnceLock::new();
                        MEMORY_MAP.get_or_init(|| RwLock::new(MemoryMap::new()))
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    fn with_map&ltT, F&gt(f: F) -> T
                    where
                        F: FnOnce(&MemoryMap) -> T,
                    {
                        f(&global_memory_map().read().unwrap())
                    }

                    fn with_map_mut&ltT, F&gt(f: F) -> T
                    where
                        F: FnOnce(&mut MemoryMap) -> T,
                    {
                        f(&mut global_memory_map().write().unwrap())
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    unsafe fn segfault_handler(
                        sig: c_int,
                        info: *mut siginfo_t,
                        ctx: *mut ucontext_t,
                    ) {
                        with_map(move |map| {
                            let si_addr = (*info).si_addr() as usize;

                            if let Some(inner_ptr) = map.get(&si_addr) {
                                let inner = &mut *(*inner_ptr as *mut MemoryInner);

                                if inner.process_segv(si_addr).is_err() {
                                    call_old_action(sig, info, ctx);
                                }

                                return;
                            }

                            call_old_action(sig, info, ctx);
                        });
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    fn setup_action() -> sigaction {
                        unsafe {
                            static OLD_ACTION: OnceLock&ltsigaction&gt = OnceLock::new();

                            *OLD_ACTION.get_or_init(|| {
                                let mut sa_mask = MaybeUninit::&ltsigset_t&gt::uninit();
                                sigemptyset(sa_mask.as_mut_ptr());

                                let act = sigaction {
                                    sa_sigaction: segfault_handler as _,
                                    sa_mask: sa_mask.assume_init(),
                                    sa_flags: SA_SIGINFO,
                                    #[cfg(target_os = "linux")]
                                    sa_restorer: None,
                                };
                                let mut old_act = MaybeUninit::&ltsigaction&gt::uninit();

                                if libc::sigaction(SIGSEGV, &act, old_act.as_mut_ptr()) != 0 {
                                    process::exit(1);
                                }

                                old_act.assume_init()
                            })
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    pub struct Memory(&'static mut MemoryInner);

                    impl Memory {
                        pub fn new(len: usize) -> io::Result&ltSelf&gt {
                            with_map_mut(|map| {
                                setup_action();

                                let inner = MemoryInner::new(len)?;

                                let inner_slice = inner.bytes.as_ref();

                                let inner_begin = inner_slice.as_ptr() as usize;
                                let inner_end = inner_begin + inner_slice.len();
                                let inner_range = inner_begin..inner_end;

                                let leaked_inner = Box::leak(Box::new(inner));
                                map.insert(inner_range, leaked_inner as *const MemoryInner as _);

                                Ok(Memory(leaked_inner))
                            })
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    impl Drop for Memory {
                        fn drop(&mut self) {
                            with_map_mut(|map| {
                                let inner_slice = self.0.bytes.as_ref();

                                let inner_begin = inner_slice.as_ptr() as usize;
                                let inner_end = inner_begin + inner_slice.len();
                                let inner_range = inner_begin..inner_end;

                                map.remove(inner_range);
                                unsafe {
                                    let _ = Box::from_raw(self.0);
                                }
                            });
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    impl AsRef<[u8]> for Memory {
                        fn as_ref(&self) -> &[u8] {
                            let inner = &*self.0;
                            inner.bytes.as_ref()
                        }
                    }

                    impl AsMut<[u8]> for Memory {
                        fn as_mut(&mut self) -> &mut [u8] {
                            let inner = &mut *self.0;
                            inner.bytes.as_mut()
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    impl Deref for Memory {
                        type Target = [u8];

                        fn deref(&self) -> &Self::Target {
                            self.as_ref()
                        }
                    }

                    impl DerefMut for Memory {
                        fn deref_mut(&mut self) -> &mut Self::Target {
                            self.as_mut()
                        }
                    }
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    #[test]
                    fn read_write() -> io::Result<()> {
                        let mut memory = Memory::new(1000)?;

                        memory[42] = 42;

                        assert_eq!(memory[42], 42, "Memory will be written to correctly");
                        assert!(
                            memory.0.dirty_page_bits.as_ref()[0].load(Ordering::SeqCst),
                            "The first page will be marked as dirty"
                        );

                        Ok(())
                    }
                </code></pre>
            </section>
        </section>
        <section>
            <section><h3>Gotchas</h3></section>
            <section>
                <p class=syscall-title>Send and Sync</p>
                <pre><code lang=rust data-trim data-noescape>
                    /// This does not compile if `Send` isn't implemented for `Memory`
                    #[test]
                    fn send() -> io::Result<()> {
                        use std::thread;
                        let mut memory = Memory::new(1000)?;

                        // error[E0277]
                        thread::spawn(move || {
                            memory[42] = 42;
                        })
                        .join()
                        .unwrap();
                        Ok(())
                    }
                </code></pre>
            </section>
            <section>
                <div>
                    <p class=syscall-title>Send and Sync</p>
                    <ul class=syscall-description>
                        <li>A type is Send if it is safe to send it to another thread</li>
                        <li>A type is Sync if it is safe to share between threads (T is Sync if and only if &T is Send)</li>
                    </ul>
                </div>
                <div class=fragment>
                    <p class="syscall-title" style="margin-top: 1em">Rules for references</p>
                    <ul class=syscall-description>
                        <li>At any given time, you can have either one mutable reference or any number of immutable references</li>
                        <li>References must always be valid</li>
                    </ul>
                </div>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    unsafe impl Send for Memory {}
                    unsafe impl Sync for Memory {}
                </code></pre>
            </section>
            <section>
                <pre><code lang=rust data-trim data-noescape>
                    /// This is available on slices, but (maybe fortunately) it is
                    /// unstable. Luckily, we used atomics to track dirty pages.
                    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]);
                </code></pre>
            </section>
        </section>
        <section>
            <section>
                <h3>Use Cases</h3>
                <ul>
                    <li class="fragment stategy-item">Keep track of written pages</li>
                    <li class="fragment stategy-item">Load page content dynamically on reads</li>
                    <li class="fragment stategy-item">Moving back in time with snapshots</li>
                </ul>
            </section>
            <section>
                <h3>Useful Links</h3>
                <ul class=useful-links-list>
                    <li><a href="https://docs.rs/crumbles" target="_blank">crumbles</a> - implementing a version of memory tracking, developed for...</li>
                    <li><a href="https://docs.rs/piecrust" target="_blank">piecrust</a> - Dusk's VM implementation</li>
                    <li><a href="https://docs.rs/piecrust" target="_blank">libc</a> - FFI bindings to platform stuff</li>
                    <li>
                        <a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank">mmap</a>,
                        <a href="https://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank">mprotect</a>, and
                        <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html" target="_blank">sigaction</a>
                        man pages
                    </li>
                </ul>
            </section>
            <section>
                <h3>Thank You!</h3>
                <ul class=useful-links-list>
                    <li><a href="https://docs.rs/crumbles" target="_blank">crumbles</a> - implementing a version of memory tracking, developed for...</li>
                    <li><a href="https://docs.rs/piecrust" target="_blank">piecrust</a> - Dusk's VM implementation</li>
                    <li><a href="https://docs.rs/piecrust" target="_blank">libc</a> - FFI bindings to platform stuff</li>
                    <li>
                        <a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank">mmap</a>,
                        <a href="https://man7.org/linux/man-pages/man2/mprotect.2.html" target="_blank">mprotect</a>, and
                        <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html" target="_blank">sigaction</a>
                        man pages
                    </li>
                </ul>
            </section>
            <section>
                <div style="display: flex; justify-content: left; margin-bottom: 1em">
                    <h3>Thank You!</h3>
                </div>

                <div class=intro>
                    <div class=contact-info>
                        <div class=contact-row>
                            Eduardo Leegwater Sim√µes
                        </div>
                        <div class=contact-row>
                            Software Engineer
                        </div>
                        <div class=contact-row>
                            <a class=contact-link href="https://www.linkedin.com/in/eduardo-leegwater-sim%C3%B5es" target="_blank">
                                <img src="../images/linkedin-logo.svg" alt="linkedin">
                            </a>
                            <a class=contact-link href="https://github.com/ureeves" target="_blank">
                                <img src="../images/github-logo.svg" alt="github">
                            </a>
                            <a class=contact-link href="mailto:soft@ureeves.com" target="_blank">
                                <img src="../images/email-round.svg" alt="email">
                            </a>
                        </div>
                    </div>

                    <div class=company-logos>
                        <img class=contact-logo-dusk src="../images/dusk-logo.svg" alt="dusk">
                        <img class=contact-logo-rust src="../images/rust-logo.png" alt="rust">
                    </div>
                </div>
            </section>
        </section>
    </div>
</div>

<script src="../dist/reveal.js"></script>
<script src="../plugin/notes/notes.js"></script>
<script src="../plugin/markdown/markdown.js"></script>
<script src="../plugin/highlight/highlight.js"></script>

<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
